//
// build.gradle in TeamCode
//
// Most of the definitions for building your module reside in a common, shared
// file 'build.common.gradle'. Being factored in this way makes it easier to
// integrate updates to the FTC into your code. If you really need to customize
// the build definitions, you can place those customizations in this file, but
// please think carefully as to whether such customizations are really necessary
// before doing so.


// Custom definitions may go here

// Include common definitions from above.

buildscript {
    repositories {
        mavenCentral()
        maven {
            url "https://repo.dairy.foundation/releases"
        }
    }
    dependencies {
        classpath "dev.frozenmilk:Load:0.2.4"
    }
}

apply from: '../build.common.gradle'
apply from: '../build.dependencies.gradle'
apply plugin: 'org.jetbrains.kotlin.android'
apply plugin: 'dev.frozenmilk.sinister.sloth.load'

android {
    namespace = 'org.firstinspires.ftc.teamcode'
    kotlinOptions {
        jvmTarget = '1.8'
    }

    compileSdk 35
    defaultConfig {
        minSdk 24
    }

    testOptions {
        unitTests.returnDefaultValues = true
        compileOptions {
            sourceCompatibility JavaVersion.VERSION_11
            targetCompatibility JavaVersion.VERSION_11
        }
        kotlinOptions {
            jvmTarget = '11'
        }
    }

    packagingOptions {
        jniLibs.useLegacyPackaging true
    }

    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.28.3"
        }
    }
}

apply plugin: 'org.mozilla.rust-android-gradle.rust-android'

def homePath = System.properties['user.home']
cargo {
    module  = "src/main/rust/rerun"
    libname = "rerun"
    targets = ["arm", "arm64", "linux-x86-64", "win32-x86-64-msvc", "darwin"]

    rustcCommand = new File(homePath, ".cargo/bin/rustc")
    cargoCommand = new File(homePath, ".cargo/bin/cargo")
}

afterEvaluate {
    def cargoBuildArm = tasks.named("cargoBuildArm64")

    tasks.matching { it.name.startsWith("cargoBuild") }.configureEach {
        // Skip Gradle's up-to-date checks so cargo always produces a fresh shared object.
        //outputs.upToDateWhen { false }
    }

    tasks.matching { it.name.startsWith("merge") && it.name.endsWith("JniLibFolders") }.configureEach {
        dependsOn(cargoBuildArm)
    }
    tasks.matching { it.name.startsWith("merge") && it.name.endsWith("NativeLibs") }.configureEach {
        dependsOn(cargoBuildArm)
    }
    tasks.matching { it.name.startsWith("package") }.configureEach {
        dependsOn(cargoBuildArm)
    }
}

def desktopCopyTargets = [
    "cargoBuildLinux-x86-64"      : ["desktop/linux-x86-64", "librerun.so"],
    "cargoBuildWin32-x86-64-msvc" : ["desktop/win32-x86-64-msvc", "librerun.dll"],
    "cargoBuildDarwin"            : ["desktop/darwin", "librerun.dylib"],
]

def desktopCargoTask = null
def osName = System.getProperty("os.name").toLowerCase()
if (osName.contains("win")) {
    desktopCargoTask = "cargoBuildWin32-x86-64-msvc"
} else if (osName.contains("mac") || osName.contains("darwin")) {
    desktopCargoTask = "cargoBuildDarwin"
} else if (osName.contains("linux")) {
    desktopCargoTask = "cargoBuildLinux-x86-64"
}

tasks.configureEach { task ->
    def copySpec = desktopCopyTargets[task.name]
    if (copySpec != null) {
        task.doLast {
            def (String relativeDir, String fileName) = copySpec
            def builtLib = file("$buildDir/rustJniLibs/${relativeDir}/${fileName}")
            if (!builtLib.exists()) {
                logger.warn("Expected rerun library not found at ${builtLib.path}")
                return
            }

            def targetDir = file("${projectDir}/src/test/jniLibs")
            if (!targetDir.exists()) {
                targetDir.mkdirs()
            }

            copy {
                from builtLib
                into targetDir
            }
        }
    }
}

Properties local = new Properties()
local.load(project.rootProject.file('local.properties').newDataInputStream())

def drakeDesktopBuildDir = file("$buildDir/native-desktop")
def drakeDesktopLibDir = file("$buildDir/native-desktop/lib")
def drakeDirProp = local.getProperty("drake.dir")
def drakePrefixProp = local.getProperty("drake.prefix")
def drakeDefaultDir = file("/opt/drake/lib/cmake/drake")

tasks.register("cmakeConfigureDrakeDesktop", Exec) {
    workingDir projectDir
    commandLine "/usr/bin/cmake",
            "-S", "src/main/cpp",
            "-B", drakeDesktopBuildDir,
            "-GNinja",
            "-DCMAKE_BUILD_TYPE=Debug",
            "-DENABLE_DRAKE=ON",
            "-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=${drakeDesktopLibDir}",
            "-DCMAKE_RUNTIME_OUTPUT_DIRECTORY=${drakeDesktopLibDir}",
            "-DANDROID=OFF",
            "-DCMAKE_MAKE_PROGRAM=/usr/bin/ninja"

    def drakeDir = drakeDirProp ?: System.getenv("DRAKE_DIR")
    def drakePrefix = drakePrefixProp ?: System.getenv("DRAKE_PREFIX")
    if (drakeDir != null && !drakeDir.isEmpty()) {
        args "-Ddrake_DIR=${drakeDir}"
    } else if (drakePrefix != null && !drakePrefix.isEmpty()) {
        args "-DCMAKE_PREFIX_PATH=${drakePrefix}"
    } else if (drakeDefaultDir.exists()) {
        args "-Ddrake_DIR=${drakeDefaultDir}"
    }
}

tasks.register("cmakeBuildDrakeDesktop", Exec) {
    workingDir projectDir
    dependsOn "cmakeConfigureDrakeDesktop"
    commandLine "/usr/bin/cmake", "--build", drakeDesktopBuildDir, "--config", "Debug"

    doLast {
        def targetDir = file("${projectDir}/src/test/jniLibs")
        if (!targetDir.exists()) {
            targetDir.mkdirs()
        }
        copy {
            from "${drakeDesktopLibDir}/libnative-lib.so"
            into targetDir
        }
    }
}

tasks.matching { it.name == "test" || it.name.endsWith("UnitTest") }.configureEach {
    dependsOn "cmakeBuildDrakeDesktop"
    if (desktopCargoTask != null) {
        dependsOn desktopCargoTask
    }
}

repositories {
    mavenCentral()
    maven { url = "https://mymaven.bylazar.com/releases" }

    maven {
        name = "choreolib"
        url = uri("https://maven.pkg.github.com/NullFTC/choreolib")
        credentials {
            username = local.getProperty('username')
            password = local.getProperty('apiKey')
        }
    }

    // Dairy releases repository
    maven {
        url = "https://repo.dairy.foundation/releases"
    }
    // Dairy snapshots repository
    maven {
        url = "https://repo.dairy.foundation/snapshots"
    }
}

project.ext.jomlVersion = "1.10.8"

dependencies {
    implementation("dev.frozenmilk.sinister:Sloth:0.2.4")
    implementation project(':FtcRobotController')

    implementation "org.joml:joml:${jomlVersion}"

    implementation("nullftc:common:1.3-snapshot") {
        exclude group: "com.google.code.gson", module: "gson"
    }

    testImplementation platform("org.junit:junit-bom:5.13.4")
    testImplementation "org.junit.jupiter:junit-jupiter"
    testRuntimeOnly "org.junit.platform:junit-platform-launcher"
    testImplementation "org.jetbrains.kotlinx:kandy-lets-plot:0.8.0"
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2'

    // Viz dependencies moved to implementation for main source access
    implementation "io.javalin:javalin:6.1.3"
    implementation "org.slf4j:slf4j-simple:2.0.7"
    implementation "com.fasterxml.jackson.core:jackson-databind:2.15.0"

    implementation "com.bylazar:fullpanels:1.0.7"
    implementation "com.bylazar:telemetry:1.0.5"
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
    systemProperty "projectDir", project.projectDir.absolutePath
    systemProperty "choreoDir", "$project.projectDir.absolutePath/choreo"
}

tasks.register("syncChoreo") {
    group = "deployment"
    description = "Syncs TeamCode/choreo contents to /sdcard/FIRST/choreo when the remote directory exists"

    doLast {
        def adb = android.adbExecutable
        if (adb == null || !adb.exists()) {
            throw new GradleException("adb executable not found. Ensure the Android SDK is configured.")
        }

        def remoteDir = "/sdcard/FIRST/choreo"
        def localDir = file("choreo")

        if (!localDir.exists()) {
            logger.lifecycle("Local choreo directory ${localDir} not found; nothing to upload.")
            return
        }

        def checkResult = project.exec {
            executable adb.absolutePath
            args "shell", "if [ -d ${remoteDir} ]; then exit 0; else exit 1; fi"
            ignoreExitValue = true
        }

        if (checkResult.exitValue != 0) {
            logger.lifecycle("Remote choreo directory ${remoteDir} not present; skipping sync.")
            return
        }

        project.exec {
            executable adb.absolutePath
            args "shell", "if [ -d ${remoteDir} ]; then rm -rf ${remoteDir} && mkdir -p ${remoteDir}; fi"
        }

        project.exec {
            executable adb.absolutePath
            args "push", "${localDir.absolutePath}/.", remoteDir
        }

        logger.lifecycle("Synced choreo assets to ${remoteDir}")
    }
}