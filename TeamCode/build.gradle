//
// build.gradle in TeamCode
// Most of the definitions for building your module reside in a common, shared file 'build.common.gradle'. Being factored in this way makes it easier to integrate updates to the FTC into your code. If you really need to customize the build definitions, you can place those customizations in this file, but please think carefully as to whether such customizations are really necessary
// before doing so.


// Custom definitions may go here

// Include common definitions from above.

buildscript {
    repositories {
        mavenCentral()

        maven {
            name = "sloth"
            url = uri("https://maven.pkg.github.com/Veratay/sloth")
            credentials {
                Properties local = new Properties()
                local.load(project.rootProject.file('local.properties').newDataInputStream())

                username = local.getProperty('username')
                password = local.getProperty('apiKey')
            }
        }
    }
    dependencies {
        classpath 'dev.frozenmilk:load:SNAPSHOT-371b2c6'
    }
}

apply from: '../build.common.gradle'
apply from: '../build.dependencies.gradle'
apply plugin: 'org.jetbrains.kotlin.android'
apply plugin: 'dev.frozenmilk.sinister.sloth.load'

android {
    namespace = 'org.firstinspires.ftc.teamcode'
    kotlinOptions {
        jvmTarget = '1.8'
    }

    compileSdk 35
    defaultConfig {
        minSdk 24
        resValue "string", "sloth_teamcode_package", "sigmacorns"
    }

    testOptions {
        unitTests.returnDefaultValues = true
        compileOptions {
            sourceCompatibility JavaVersion.VERSION_11
            targetCompatibility JavaVersion.VERSION_11
        }
        kotlinOptions {
            jvmTarget = '11'
        }
    }

    packagingOptions {
        jniLibs.useLegacyPackaging true
    }

    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.28.3"
        }
    }
}

apply plugin: 'org.mozilla.rust-android-gradle.rust-android'

def homePath = System.properties['user.home']
cargo {
    module  = "src/main/rust/rerun"
    libname = "rerun"
    targets = ["arm", "arm64", "linux-x86-64", "win32-x86-64-msvc", "darwin"]

    rustcCommand = new File(homePath, ".cargo/bin/rustc")
    cargoCommand = new File(homePath, ".cargo/bin/cargo")
}

def desktopCopyTargets = [
    "cargoBuildLinux-x86-64"      : ["desktop/linux-x86-64", "librerun.so"],
    "cargoBuildWin32-x86-64-msvc" : ["desktop/win32-x86-64-msvc", "librerun.dll"],
    "cargoBuildDarwin"            : ["desktop/darwin", "librerun.dylib"],
]

def androidCopyTargets = [
    "cargoBuildArm64": ["android/arm64-v8a", "librerun.so"],
]

tasks.configureEach { task ->
    def copySpec = desktopCopyTargets[task.name]
    def targetDir = file("${projectDir}/src/test/jniLibs")
    if (copySpec == null) {
        copySpec = androidCopyTargets[task.name]
        targetDir = file("${projectDir}/src/main/jniLibs/arm64-v8a")
    }
    if (copySpec != null) {
        task.doLast {
            def (String relativeDir, String fileName) = copySpec
            def builtLib = file("$buildDir/rustJniLibs/${relativeDir}/${fileName}")
            if (!builtLib.exists()) {
                logger.warn("Expected rerun library not found at ${builtLib.path}")
                return
            }

            if (!targetDir.exists()) {
                targetDir.mkdirs()
            }

            copy {
                from builtLib
                into targetDir
            }
            delete(builtLib)
        }
    }
}

Properties local = new Properties()
local.load(project.rootProject.file('local.properties').newDataInputStream())

def drakeDesktopBuildDir = file("$buildDir/native-desktop")
def drakeDesktopLibDir = file("$buildDir/native-desktop/lib")
def drakeDirProp = local.getProperty("drake.dir")
def drakePrefixProp = local.getProperty("drake.prefix")
def drakeDefaultDir = file("/opt/drake/lib/cmake/drake")

tasks.register("cmakeConfigureDrakeDesktop", Exec) {
    workingDir projectDir
    commandLine "/usr/bin/cmake",
            "-S", "src/main/cpp",
            "-B", drakeDesktopBuildDir,
            "-GNinja",
            "-DCMAKE_BUILD_TYPE=Debug",
            "-DENABLE_DRAKE=ON",
            "-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=${drakeDesktopLibDir}",
            "-DCMAKE_RUNTIME_OUTPUT_DIRECTORY=${drakeDesktopLibDir}",
            "-DANDROID=OFF",
            "-DCMAKE_MAKE_PROGRAM=/usr/bin/ninja"

    def drakeDir = drakeDirProp ?: System.getenv("DRAKE_DIR")
    def drakePrefix = drakePrefixProp ?: System.getenv("DRAKE_PREFIX")
    if (drakeDir != null && !drakeDir.isEmpty()) {
        args "-Ddrake_DIR=${drakeDir}"
    } else if (drakePrefix != null && !drakePrefix.isEmpty()) {
        args "-DCMAKE_PREFIX_PATH=${drakePrefix}"
    } else if (drakeDefaultDir.exists()) {
        args "-Ddrake_DIR=${drakeDefaultDir}"
    }
}

tasks.register("cmakeBuildDrakeDesktop", Exec) {
    workingDir projectDir
    dependsOn "cmakeConfigureDrakeDesktop"
    commandLine "/usr/bin/cmake", "--build", drakeDesktopBuildDir, "--config", "Debug"

    doLast {
        def targetDir = file("${projectDir}/src/test/jniLibs")
        if (!targetDir.exists()) {
            targetDir.mkdirs()
        }
        copy {
            from "${drakeDesktopLibDir}/libnative-lib.so"
            into targetDir
        }
    }
}

tasks.matching { it.name == "test" || it.name.endsWith("UnitTest") }.configureEach {
    dependsOn "cmakeBuildDrakeDesktop"
}

repositories {
    mavenCentral()
    maven { url = "https://mymaven.bylazar.com/releases" }
    mavenLocal()

    maven {
        name = "choreolib"
        url = uri("https://maven.pkg.github.com/NullFTC/choreolib")
        credentials {
            username = local.getProperty('username')
            password = local.getProperty('apiKey')
        }
    }

    maven {
        name = "sloth"
        url = uri("https://maven.pkg.github.com/Veratay/sloth")
        credentials {
            username = local.getProperty('username')
            password = local.getProperty('apiKey')
        }
    }

    // Dairy releases repository
    maven {
        url = "https://repo.dairy.foundation/releases"
    }
}

project.ext.jomlVersion = "1.10.8"

dependencies {
    implementation("dev.frozenmilk.sinister:sloth:snapshot-fe26442")
    implementation project(':FtcRobotController')

    implementation "org.joml:joml:${jomlVersion}"

    implementation("nullftc:common:1.3-snapshot") {
        exclude group: "com.google.code.gson", module: "gson"
    }

    testImplementation platform("org.junit:junit-bom:5.13.4")
    testImplementation "org.junit.jupiter:junit-jupiter"
    testRuntimeOnly "org.junit.platform:junit-platform-launcher"
    testImplementation "org.jetbrains.kotlinx:kandy-lets-plot:0.8.0"

    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2'

    implementation "io.javalin:javalin:6.1.3"
    implementation "org.slf4j:slf4j-simple:2.0.7"
    implementation "com.fasterxml.jackson.core:jackson-databind:2.15.0"

    implementation "com.bylazar:fullpanels:1.0.7"
    implementation "com.bylazar:telemetry:1.0.5"
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
    systemProperty "projectDir", project.projectDir.absolutePath
    systemProperty "choreoDir", "$project.projectDir.absolutePath/choreo"
}

tasks.register("syncChoreo") {
    group = "deployment"
    description = "Syncs TeamCode/choreo contents to /sdcard/FIRST/choreo when the remote directory exists"

    doLast {
        def adb = android.adbExecutable
        if (adb == null || !adb.exists()) {
            throw new GradleException("adb executable not found. Ensure the Android SDK is configured.")
        }

        def remoteDir = "/sdcard/FIRST/choreo"
        def localDir = file("choreo")

        if (!localDir.exists()) {
            logger.lifecycle("Local choreo directory ${localDir} not found; nothing to upload.")
            return
        }

        def checkResult = project.exec {
            executable adb.absolutePath
            args "shell", "if [ -d ${remoteDir} ]; then exit 0; else exit 1; fi"
            ignoreExitValue = true
        }

        if (checkResult.exitValue != 0) {
            logger.lifecycle("Remote choreo directory ${remoteDir} not present; skipping sync.")
            return
        }

        project.exec {
            executable adb.absolutePath
            args "shell", "if [ -d ${remoteDir} ]; then rm -rf ${remoteDir} && mkdir -p ${remoteDir}; fi"
        }

        project.exec {
            executable adb.absolutePath
            args "push", "${localDir.absolutePath}/.", remoteDir
        }

        logger.lifecycle("Synced choreo assets to ${remoteDir}")
    }
}
