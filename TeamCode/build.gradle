//
// build.gradle in TeamCode
//
// Most of the definitions for building your module reside in a common, shared
// file 'build.common.gradle'. Being factored in this way makes it easier to
// integrate updates to the FTC into your code. If you really need to customize
// the build definitions, you can place those customizations in this file, but
// please think carefully as to whether such customizations are really necessary
// before doing so.


// Custom definitions may go here

// Include common definitions from above.

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath "dev.frozenmilk:Load:SNAPSHOT-1739c47"
    }
}

apply from: '../build.common.gradle'
apply from: '../build.dependencies.gradle'
apply plugin: 'org.jetbrains.kotlin.android'
apply plugin: 'dev.frozenmilk.sinister.sloth.load'

android {
    namespace = 'org.firstinspires.ftc.teamcode'
    kotlinOptions {
        jvmTarget = '1.8'
    }

    compileSdk 35
    defaultConfig {
        minSdk 24
        resValue "string", "sloth_teamcode_package", "sigmacorns"
    }

    testOptions {
        compileOptions {
            sourceCompatibility JavaVersion.VERSION_11
            targetCompatibility JavaVersion.VERSION_11
        }
        kotlinOptions {
            jvmTarget = '11'
        }
    }

    packagingOptions {
        jniLibs.useLegacyPackaging true
    }

}

apply plugin: 'org.mozilla.rust-android-gradle.rust-android'

def homePath = System.properties['user.home']
cargo {
    module  = "src/main/rust/rerun"
    libname = "rerun"
    targets = ["arm", "arm64", "linux-x86-64", "win32-x86-64-msvc", "darwin"]

    rustcCommand = new File(homePath, ".cargo/bin/rustc")
    cargoCommand = new File(homePath, ".cargo/bin/cargo")
}

afterEvaluate {
    def cargoBuildArm = tasks.named("cargoBuildArm64")

    tasks.matching { it.name.startsWith("cargoBuild") }.configureEach {
        // Skip Gradle's up-to-date checks so cargo always produces a fresh shared object.
        //outputs.upToDateWhen { false }
    }

    tasks.matching { it.name.startsWith("merge") && it.name.endsWith("JniLibFolders") }.configureEach {
        dependsOn(cargoBuildArm)
    }
    tasks.matching { it.name.startsWith("merge") && it.name.endsWith("NativeLibs") }.configureEach {
        dependsOn(cargoBuildArm)
    }
    tasks.matching { it.name.startsWith("package") }.configureEach {
        dependsOn(cargoBuildArm)
    }
}

def desktopCopyTargets = [
    "cargoBuildLinux-x86-64"      : ["desktop/linux-x86-64", "librerun.so"],
    "cargoBuildWin32-x86-64-msvc" : ["desktop/win32-x86-64-msvc", "librerun.dll"],
    "cargoBuildDarwin"            : ["desktop/darwin", "librerun.dylib"],
]

tasks.configureEach { task ->
    def copySpec = desktopCopyTargets[task.name]
    if (copySpec != null) {
        task.doLast {
            def (String relativeDir, String fileName) = copySpec
            def builtLib = file("$buildDir/rustJniLibs/${relativeDir}/${fileName}")
            if (!builtLib.exists()) {
                logger.warn("Expected rerun library not found at ${builtLib.path}")
                return
            }

            def targetDir = file("${projectDir}/src/test/jniLibs")
            if (!targetDir.exists()) {
                targetDir.mkdirs()
            }

            copy {
                from builtLib
                into targetDir
            }
        }
    }
}

Properties local = new Properties()
local.load(project.rootProject.file('local.properties').newDataInputStream())

repositories {
    mavenCentral()
    mavenLocal()
    maven { url = "https://mymaven.bylazar.com/releases" }

    maven {
        name = "choreolib"
        url = uri("https://maven.pkg.github.com/NullFTC/choreolib")
        credentials {
            username = local.getProperty('username')
            password = local.getProperty('apiKey')
        }
    }

    // Dairy releases repository
    maven {
        url = "https://repo.dairy.foundation/releases"
    }
    // Dairy snapshots repository
    maven {
        url = "https://repo.dairy.foundation/snapshots"
    }
}

project.ext.jomlVersion = "1.10.8"

dependencies {
    implementation("dev.frozenmilk.sinister:Sloth:SNAPSHOT-0f3df49")
    implementation project(':FtcRobotController')

    implementation "org.joml:joml:${jomlVersion}"

    implementation("nullftc:common:1.3-snapshot") {
        exclude group: "com.google.code.gson", module: "gson"
    }

    testImplementation platform("org.junit:junit-bom:5.13.4")
    testImplementation "org.junit.jupiter:junit-jupiter"
    testRuntimeOnly "org.junit.platform:junit-platform-launcher"
    testImplementation "org.jetbrains.kotlinx:kandy-lets-plot:0.8.0"
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2'

    implementation "com.bylazar:fullpanels:1.0.7"
    implementation "com.bylazar:telemetry:1.0.5"
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
    systemProperty "projectDir", project.projectDir.absolutePath
    systemProperty "choreoDir", "$project.projectDir.absolutePath/choreo"
}

tasks.register("syncChoreo") {
    group = "deployment"
    description = "Syncs TeamCode/choreo contents to /sdcard/FIRST/choreo when the remote directory exists"

    doLast {
        def adb = android.adbExecutable
        if (adb == null || !adb.exists()) {
            throw new GradleException("adb executable not found. Ensure the Android SDK is configured.")
        }

        def remoteDir = "/sdcard/FIRST/choreo"
        def localDir = file("choreo")

        if (!localDir.exists()) {
            logger.lifecycle("Local choreo directory ${localDir} not found; nothing to upload.")
            return
        }

        def checkResult = project.exec {
            executable adb.absolutePath
            args "shell", "if [ -d ${remoteDir} ]; then exit 0; else exit 1; fi"
            ignoreExitValue = true
        }

        if (checkResult.exitValue != 0) {
            logger.lifecycle("Remote choreo directory ${remoteDir} not present; skipping sync.")
            return
        }

        project.exec {
            executable adb.absolutePath
            args "shell", "if [ -d ${remoteDir} ]; then rm -rf ${remoteDir} && mkdir -p ${remoteDir}; fi"
        }

        project.exec {
            executable adb.absolutePath
            args "push", "${localDir.absolutePath}/.", remoteDir
        }

        logger.lifecycle("Synced choreo assets to ${remoteDir}")
    }
}
